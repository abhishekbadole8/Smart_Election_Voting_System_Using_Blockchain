{
  "language": "Solidity",
  "sources": {
    "contracts/VoteSession.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ncontract VoteSession {\n    event CandidateRegistered(address _address, string _name, uint256 _id);\n    event VotingStarted(uint256 _timestamp);\n    event VotingEnded(uint256 _timestamp);\n\n    error NotOwner();\n    error NotEnoughCandidates();\n    error NotEnoughVotes();\n    error AlreadyVoted();\n    error CandidateDoesNotExist();\n    error AlreadyRegistered();\n    error RegistrationIsClosed();\n    error VotingIsClosed();\n    error CannotRegisterInVotingPeriod();\n    error NotUniqueID();\n\n    struct Candidate {\n        string name;\n        uint256 id;\n        uint256 voteCount;\n        address candAddress;\n    }\n\n    enum RegistrationStatus {\n        OPEN,\n        CLOSED\n    }\n\n    enum VotingStatus {\n        OPEN,\n        CLOSED\n    }\n\n    RegistrationStatus public registrationStatus;\n    VotingStatus public votingStatus;\n    mapping(uint256 => Candidate) public candidates;\n    mapping(uint256 => uint256) public indexToId;\n    mapping(address => bool) public alreadyVoted;\n    mapping(address => bool) public alreadyRegisteredCandidate;\n    mapping(address => bool) public voters;\n    address[] public allVoters;\n    Candidate[] public winners;\n    uint256 public numberOfCandidates;\n    uint256 public numberOfWinners;\n    uint256 public totalVotes;\n    address public owner;\n\n    constructor() {\n        registrationStatus = RegistrationStatus.CLOSED;\n        votingStatus = VotingStatus.CLOSED;\n        owner = msg.sender;\n    }\n\n    function startNewElection() public checkOwner {\n        registrationStatus = RegistrationStatus.CLOSED;\n        votingStatus = VotingStatus.CLOSED;\n        for (uint256 i = 0; i <= numberOfCandidates; i++) {\n            uint256 ID = indexToId[i];\n            address candidateAddress = candidates[ID].candAddress;\n            alreadyRegisteredCandidate[candidateAddress] = false;\n            address tempAddress;\n            candidates[ID] = Candidate({\n                name: \"\",\n                id: 0,\n                voteCount: 0,\n                candAddress: tempAddress\n            });\n            indexToId[i] = 0;\n        }\n        for (uint256 i = 0; i < allVoters.length; i++) {\n            alreadyVoted[allVoters[i]] = false;\n            voters[allVoters[i]] = false;\n        }\n        allVoters = new address[](0);\n        for (uint256 i = 0; i < numberOfWinners; i++) {\n            winners.pop();\n        }\n        numberOfCandidates = 0;\n        totalVotes = 0;\n        numberOfWinners = 0;\n    }\n\n    function registerCandidate(\n        uint256 _id,\n        string memory _name\n    ) public isCandidateRegistrationOpen {\n        if (alreadyRegisteredCandidate[msg.sender]) {\n            revert AlreadyRegistered();\n        }\n        if (candidates[_id].id > 0) {\n            revert NotUniqueID();\n        }\n\n        indexToId[numberOfCandidates] = _id;\n        candidates[_id] = Candidate({\n            name: _name,\n            id: _id,\n            voteCount: 0,\n            candAddress: msg.sender\n        });\n        numberOfCandidates++;\n        alreadyRegisteredCandidate[msg.sender] = true;\n\n        emit CandidateRegistered(msg.sender, _name, numberOfCandidates);\n    }\n\n    function registerVoter() public {\n        if (voters[msg.sender] == true) {\n            revert AlreadyRegistered();\n        }\n\n        voters[msg.sender] = true;\n        allVoters.push(msg.sender);\n    }\n\n    function registrationStart() public checkOwner {\n        if (votingStatus == VotingStatus.OPEN) {\n            revert CannotRegisterInVotingPeriod();\n        }\n        registrationStatus = RegistrationStatus.OPEN;\n    }\n\n    function registrationStop() public checkOwner {\n        registrationStatus = RegistrationStatus.CLOSED;\n    }\n\n    function votingStart() public checkOwner {\n        if (numberOfCandidates < 2) {\n            revert NotEnoughCandidates();\n        }\n        if (registrationStatus == RegistrationStatus.OPEN) {\n            registrationStop();\n        }\n        votingStatus = VotingStatus.OPEN;\n    }\n\n    function votingStop() public checkOwner {\n        registrationStatus = RegistrationStatus.CLOSED;\n    }\n\n    function vote(uint256 _candidateId) public isVotingOpen {\n        if (alreadyVoted[msg.sender]) {\n            revert AlreadyVoted();\n        }\n\n        alreadyVoted[msg.sender] = true;\n        candidates[_candidateId].voteCount++;\n        totalVotes++;\n    }\n\n   \n\n    function declareResult() public checkOwner {\n        if (numberOfCandidates < 2) {\n            revert NotEnoughCandidates();\n        }\n        if (totalVotes < 1) {\n            revert NotEnoughVotes();\n        }\n        uint256 mostVotes;\n        for (uint256 i = 0; i < numberOfCandidates; i++) {\n            uint256 id = indexToId[i];\n            if (candidates[id].voteCount > mostVotes) {\n                mostVotes = candidates[id].voteCount;\n            }\n        }\n\n        // if size of winners is greater than 1\n        // then its a draw\n        // Candidate[] memory winners = new Candidate[](numberOfCandidates);\n        for (uint256 i = 0; i < numberOfCandidates; i++) {\n            uint256 id = indexToId[i];\n            if (candidates[id].voteCount == mostVotes) {\n                // winners[i] = candidates[id];\n                winners.push(candidates[id]);\n                numberOfWinners++;\n            }\n        }\n        registrationStatus = RegistrationStatus.CLOSED;\n        votingStatus = VotingStatus.CLOSED;\n    }\n\n    function getWinners() public view returns (Candidate[] memory) {\n        return winners;\n    }\n\n    function getCandidates() public view returns (Candidate[] memory) {\n        Candidate[] memory allCandidates = new Candidate[](numberOfCandidates);\n        for (uint256 i = 0; i < numberOfCandidates; i++) {\n            uint256 id = indexToId[i];\n            allCandidates[i] = candidates[id];\n        }\n        return (allCandidates);\n    }\n\n    function getCandidate(\n        uint256 _candidateId\n    ) public view returns (Candidate memory) {\n        return candidates[_candidateId];\n    }\n\n    function getNumberOfCandidates() public view returns (uint256) {\n        return numberOfCandidates;\n    }\n\n\n    function getTotalVotes() public view returns (uint256) {\n        return totalVotes;\n    }\n\n    function getRegistrationStatus() public view returns (RegistrationStatus) {\n        return registrationStatus;\n    }\n\n    function getVotingStatus() public view returns (VotingStatus) {\n        return votingStatus;\n    }\n\n    function getOwner() public view returns (address) {\n        return owner;\n    }\n\n    function checkVoterIsValidOrNot() public view returns (bool) {\n        return voters[msg.sender];\n    }\n\n    function checkVoterAlreadyVotedOrNot() public view returns (bool) {\n        return alreadyVoted[msg.sender];\n    }\n\n    function checkCandidateAlreadyRegisteredOrNot() public view returns (bool) {\n        return alreadyRegisteredCandidate[msg.sender];\n    }\n\n    modifier isCandidateRegistrationOpen() {\n        if (registrationStatus == RegistrationStatus.CLOSED) {\n            revert RegistrationIsClosed();\n        }\n        _;\n    }\n\n    modifier isVotingOpen() {\n        if (votingStatus == VotingStatus.CLOSED) {\n            revert VotingIsClosed();\n        }\n        _;\n    }\n\n    modifier checkOwner() {\n        if (msg.sender != owner) {\n            revert NotOwner();\n        }\n        _;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}